最近看了对递归函数效率的改进部分的知识，主要来源于尹老师的书作。

毫无疑问，递归是一个用起来玄乎乎的，理解起来更费劲的一个知识点，从大学更接触到最后能够理解它大概过去了3年的时间，也就是说直到编译原理的时候自己手写了编译器之后才明白了递归函数究竟是如何被编译器解析出来的，也对计算机程序设计中非常重要要的函数调用机制有了深刻的理解，好吧，暂时不去回顾这些历史了，直接说一下关键之处吧，本篇博客主要对递归函数的优化方法做一个介绍，也是有很多的干货的。

# 尾递归函数的非递归化

这个还是比较常见的，比如什么求序列和，求阶乘的这种问题，都是尾递归的问题，其实也都是本质上不适合用递归来写的事情，尾递归的问题直接用循环展开就好啦，不需要搞递归了。尾递归很常见，同时非递归化也比较简单所以一般的编译器都会将其直接优化掉，当在gcc下使用 -O2的编译优化选项的时候，尾递归会被用循环展开替代。


# 带存储机制的递归

这个其实是针对递归过程中子问题被重复计算的缺陷提出来的改进，想法很类似于动态规划，也就是是说我要把我计算过的子问题存储下来，从而在以后需要相同的子问题的结果的时候，我需要先查表，如果表中有就直接拿来用，如果没有再进行计算，然后把计算结果存表。这种机制的改进一般包括三个步骤，第一个步骤是定义函数递归出口，第二个步骤是查表，第三个步骤是计算后存表，每个步骤只要符合了条件就可以返回函数值了。具体实例可见https://zhuanlan.zhihu.com/p/59685884 中的上楼梯问题。


# 一般递归函数的非递归化

该过程主要是模拟函数调用栈的行为，将函数参数和函数返回值进栈：每执行一个函数调用就弹出栈顶元素，参与计算，获得了返回值后存储到栈中，只要栈不为空，就持续执行该过程，算法描述如下：

1、将初始递归参数入栈；
2、当栈不为空时执行：
2.1、 弹出栈顶参数集合S;
2.2、如果S满足基础条件，则完成基础计算并返回值；
2.2、否则根据递归过程对递归参数的处理方式生成新的参数集合S'，并将S'进栈。

