# 172 Factorial Trailing Zeroes

这道题的简单应该只是讲得是代码写起来简单，但是思考的过程以及坑点一点也不简单，首先我们知道要想出现0在结尾就要有10乘进去，这样其实等价于需要有5和2，因为只要按照顺序出现一个5就必然会在他的前面出现不止一个2，所我们只需要考虑一下有多少个5就好了，但是要注意的是有的数里面止一个5，比如25， 125， 625这样的数，于是我们找到的规律是每当出现5个5之后就会再多一个5，这也就是说如果有K个5在其中就会有K/5个25在其中，以此类推，如果有K/5个25在其中，那就会有K/25个125在其中，于是这个一个可以指数化的规律，对应的题解就是log(N)的时间复杂度，这道题对复杂度有要求就意味着不能简单地数5的个数，而是要通过规律。
于是程序的主要部分代码就是：


```C++
int trailingZeroes(int n) {
        int res = 0;
        int base = n/5;
        res += base;
        while(base > 0){
            base /= 5;
            res += base;
        }
        return res;
    }
```